package com.MultiThreading.MonitorLock;

public class MonitorLockExample {

    public synchronized void task1(){
        long startTime = System.currentTimeMillis();
        System.out.println("----task1 starts with thread "+ Thread.currentThread().getName() + " At :- " + System.nanoTime() + " ns.");
        try {
            System.out.println("----Task1 Execution starts at " + startTime);
            Thread.sleep(10000);
            System.out.println("----Task1 Execution ends at " + System.currentTimeMillis());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        long endTime = System.currentTimeMillis();
        System.out.println("----task1 ends with thread " + Thread.currentThread().getName() + " And time consumed = "  + (endTime - startTime)/ 1000 + " sec");
    }

    public void task2(){
        System.out.println("Task2 starts with thread " + Thread.currentThread().getName() + " At " + System.nanoTime() + " ns");
        long startTime = System.currentTimeMillis();

        synchronized (this){
            System.out.println("inside Task2 synchronized block");
        }

        System.out.println("Task2 ends with thread " + Thread.currentThread().getName());

    }

    public void task3(){
        System.out.println("Executing Task3!!");
    }
}
